#! /bin/bash
#
#
#
#
usage() {
cat << EOF
  status
  subspack DIR - make subspack with cvmfs upstream
  subenv OLDENV (on cvmfs) NEWENV (in current subspack)
  synccache - writes sync.sh and cvmsfs.h to move local install through cache
  pushcache - copt ./bc to mu2e mirror
EOF
}

sstatus() {
  if [ ! "$SPACK_ROOT" ]; then
    echo "No spack is setup"
    usage
    return 1
  fi
  echo "PWD=$PWD"
#  echo "SPACK_ROOT=$( echo $SPACK_ROOT | sed 's/opensciencegrid.org/\./')"
  echo "SPACK_ROOT=$SPACK_ROOT"
  echo "SPACK_INSTALL=$SPACK_INSTALL"
  spack find --loaded

}


# make a local subspack with the standard location upstream
# there should be one argument which is a path to the new install
subspack() {
  local VV=true
  local DDIR=$(readlink -f $1)
  if [ ! "$DDIR" ]; then
    echo "No new directory argument is given"
    usage
    return 22
  fi
  if [ ! "$SPACK_ROOT" ]; then
    echo "No spack is setup"
    usage
    return 1
  fi

  if ! mkdir -p $DDIR ; then
    echo "Could not make new subspack directory $DDIR"
    return 1
  fi

  local ODIR=$PWD

  cd $DDIR || return 1

#  rsync -rl /exp/mu2e/app/users/rlc/spack/spack_template/ .
  rsync -rl /cvmfs/mu2e.opensciencegrid.org/DataFiles/spack/spack_template/ .

  cd spack/var/spack/repos || return 1
  RLIST="scd_recipes artdaq-spack local"
  #for RR in $RLIST builtin
  #do
  #    ln -s $SPACK_ROOT/var/spack/repos/$RR
  #done
  (
      source $DDIR/setup-env.sh

      #echo DEB0
      #spack repo list

      for RR in $RLIST fnal_art mu2e-spack
      do
          #echo "DEB $PWD/$RR"
          spack repo add --scope site $PWD/$RR > /dev/null
      done

      echo "resetting bootstrap"
      spack bootstrap root /cvmfs/mu2e.opensciencegrid.org/packages/.bootstrap.almalinux9
      echo "trusting buildcache keys"
      spack buildcache keys --install --trust

  )


#  echo "updating buildcache keys"
#  spack buildcache keys
  
  #if [ -d mu2e-spack ]; the
  #    cd mu2e-spack
  #fi
  #git clone http://github.com/Mu2e/mu2e-

}

# make a new env from spack.lock of another env
# there should be one argument which is a path to the new install
subenv() {
  local NENV="$1"
  if [ ! "$NENV" ]; then
    echo "No new env argument is given"
    usage
    return 1
  fi
  if [ "$SPACK_ENV" ]; then
      echo "Error - an env is already setup, this is an uncertain situation"
      return 1
  fi
  if [ ! "$SPACK_ROOT" ]; then
      source /cvmfs/mu2e.opensciencegrid.org/packages/setup-env.sh
  fi

  OENV="$2"
  # is no
  if [ ! "$OENV" ]; then
      # attempt to get the current env based on muse current
      ODIR=$(
         if muse setup Offline 2>&1 > /dev/null ; then
             echo $SPACK_ENV
         fi
      )
      if [ ! "$ODIR" ]; then
          echo "Error - could not setup current Offline"
      fi
      OENV=$(basename $ODIR)
  else
      # an env name was given, try to activate it in the current spack
      ODIR=$(
#echo "activate OENV=$OENV SPCAK_ROOT=$SPACK_ROOT" > s.log
#spack env list >> s.log
          spack env activate $OENV
          RC=$?
          [ $RC -ne 0 ] && exit $RC
          echo $SPACK_ENV
          exit 0
      )
  fi

  if [ ! -r $ODIR/spack.lock ]; then
      echo "Error - old env does not have a spack.lock"
      return 1
  fi
  if [ ! -r $ODIR/spack.yaml ]; then
      echo "Error - old env does not have a spack.yaml"
      return 1
  fi

  echo "making a env $NENV from $ODIR"

  local TMPD=$(mktemp -d)
  cat $ODIR/spack.lock | jq > $TMPD/spack.lock
  spack env create -d $PWD/$NENV $TMPD/spack.lock
  cp  $ODIR/spack.yaml $PWD/$NENV
  rm -rf $TMPD

}


# assuming a subspack is setup, look into the local install dir and produce
# two files sync.sh (top copy install into buildcache) and cvmfs.sh
# to run on cvmfs to install from buildcache
synccache() {

    if [ ! "$SPACK_LOCAL" ]; then
        echo SPACK_LOCAL is not set
        return 1
    fi
    PKGS=$(ls -1 $SPACK_LOCAL)
    NP=$(echo $PKGS | wc -w)
    echo "writing sync.sh and cvmfs.sh to sync $NP packages"

    rm -f sync.sh
    touch sync.sh
    chmod a+x sync.sh
    rm -f cvmfs.sh
    touch cvmfs.sh
    chmod a+x cvmfs.sh

    for PKG in $PKGS
    do
        VERS=$(ls -1 $SPACK_LOCAL/$PKG)
        for VER in $VERS
        do
            HASHES=$(ls -1 $SPACK_LOCAL/$PKG/$VER | awk -F "-" '{print $NF}')
            for HH in $HASHES
            do
                echo "spack buildcache create -k \$MYKEY --only package ./bc $PKG/$HH" >> sync.sh
                echo "spack install --cache-only $PKG/$HH" >> cvmfs.sh
            done
        done
    done

    return 0
}

# push buildcache ./bc to mu2e cache in scisoft
pushcache() {
    if [ ! -d ./bc ]; then
        echo "buildcache ./bs not found"
        return 1
    fi
    echo "Updating local index"
    spack buildcache update-index -k ./bc  || return 1
    echo "Copying to remote"
    scp -r bc/build_cache products@fifeutilgpvm03.fnal.gov:/spack_cache/mu2e || return 1
    echo "Updating remote index"
    ssh products@fifeutilgpvm03.fnal.gov ". /home/products/spack/share/spack/setup-env.sh spack ; spack --debug buildcache update-index -k /spack_cache/mu2e" || return 1
    return 0
}

#
#  main
#

if [ ! "$SPACK_ROOT" ]; then
    if [ -r /cvmfs/mu2e.opensciencegrid.org/setupmu2e-art.sh ]; then
        source /cvmfs/mu2e.opensciencegrid.org/setupmu2e-art.sh
    else
        echo "Error - can't find mu2einit setup script"
        exit 1
    fi
fi

if [ "$MU2E_OSNAME" != "al9" ]; then
    echo "smack only supported on al9 OS"
    exit 1
fi

COMMAND=$1
shift
case $COMMAND in
  -h|--help|help) usage; exit 0 ;;
  status) sstatus "$@" ;;
  subspack) subspack "$@" ;;
  subenv) subenv "$@" ;;
  synccache) synccache "$@" ;;
  pushcache) pushcache "$@" ;;
  "") echo -e "\n No command given\n";
      usage;;
  *)  echo -e "\n Unknown command \"$COMMAND\"\n";
      usage;;
esac
RC=$?
#echo "RC=$RC"
# $@ still includes arguments to the subcommand

exit $RC


## extract options and their arguments into variables.
#while getopts a:b OPTION ; do
#    echo "option=$OPTION"
#    case $OPTION in
#        a) ARG_A=$OPTARG ;;
#        b) ARG_B=1 ;;
#        *) echo "Internal error!" ; exit 1 ;;
#    esac
#done
## shift away the switches to get remainder
#echo "OPTIND=$OPTIND"
#shift $((OPTIND-1))
#PARS="$@"
#
#echo "ARG_A = $ARG_A"
#echo "ARG_B = $ARG_B"
#echo "PARS = $PARS"

// This tells emacs to view this file in c++ mode.
// Local Variables:
// mode:shell
// End:
